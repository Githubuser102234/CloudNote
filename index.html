<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Cloud Notes</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Load Lucide icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Load Marked.js for Markdown Rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Apply Inter font family */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        /* Custom scrollbar for better aesthetics */
        .notes-list::-webkit-scrollbar, .editor-content::-webkit-scrollbar, .markdown-viewer::-webkit-scrollbar {
            width: 6px;
        }

        .notes-list::-webkit-scrollbar-thumb, .editor-content::-webkit-scrollbar-thumb, .markdown-viewer::-webkit-scrollbar-thumb {
            background: #d1d5db; /* gray-300 */
            border-radius: 3px;
        }

        .notes-list::-webkit-scrollbar-thumb:hover, .editor-content::-webkit-scrollbar-thumb:hover, .markdown-viewer::-webkit-scrollbar-thumb:hover {
            background: #9ca3af; /* gray-400 */
        }
        
        /* Markdown Styling - Ensure good readability */
        .markdown-viewer {
            line-height: 1.75;
        }
        .markdown-viewer h1, .markdown-viewer h2, .markdown-viewer h3 {
            font-weight: 700;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        .markdown-viewer p {
            margin-bottom: 1em;
        }
        .markdown-viewer pre {
            background-color: #f3f4f6; /* gray-100 */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .markdown-viewer code {
            font-family: monospace;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col">

    <!-- *** 1. Loading Spinner Overlay (Always visible initially) *** -->
    <div id="loading-spinner-overlay" class="fixed inset-0 bg-gray-50 flex items-center justify-center z-[300]">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-4 border-t-indigo-500 border-gray-200 mb-3"></div>
            <p class="text-indigo-600 font-medium">Initializing Application...</p>
        </div>
    </div>

    <!-- *** 2. Auth Modal/Overlay (Hidden until routing confirms signed out state) *** -->
    <div id="auth-overlay" class="fixed inset-0 bg-white flex items-center justify-center z-[200] hidden">
        <div class="bg-white p-6 md:p-10 rounded-xl shadow-2xl w-11/12 max-w-sm transform transition-all duration-300 border border-gray-100">
            <h3 id="auth-title" class="text-3xl font-bold text-gray-900 mb-6 text-center">Sign In</h3>
            
            <div id="auth-message" class="text-sm text-center text-red-500 mb-4 hidden"></div>

            <input id="auth-email" type="email" placeholder="Email" class="w-full mb-3 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
            <input id="auth-password" type="password" placeholder="Password" class="w-full mb-4 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">

            <button id="auth-primary-btn" class="w-full py-3 mb-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 active:scale-[.99]">
                Sign In
            </button>
            
            <div class="relative flex items-center justify-center mb-4">
                <div class="flex-grow border-t border-gray-200"></div>
                <span class="flex-shrink mx-4 text-gray-400 text-sm">OR</span>
                <div class="flex-grow border-t border-gray-200"></div>
            </div>

            <button id="auth-google-btn" class="w-full py-3 flex items-center justify-center space-x-2 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-50 transition duration-150 active:scale-[.99]">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12.0004 0C8.42398 0 5.25301 1.44299 3.01168 3.73802L7.04286 7.42701C8.24522 6.55118 9.94729 6.00282 12.0004 6.00282C13.8427 6.00282 15.6548 6.6416 17.0628 7.74758L21.0939 4.05859C18.8526 1.76356 15.6816 0.000183105 12.0004 0.000183105V0ZM2.75 6.00004C1.94297 7.2185 1.50005 8.57024 1.50005 9.99999C1.50005 11.4297 1.94297 12.7815 2.75 14L6.78119 10.311C6.78119 10.311 6.81261 10.0381 6.81261 9.99999C6.81261 9.96188 6.78119 9.68903 6.78119 9.68903L2.75 6.00004ZM12.0004 24C15.6816 24 18.8526 22.2364 21.0939 19.9414L17.0628 16.2524C15.6548 17.3584 13.8427 17.9972 12.0004 17.9972C9.94729 17.9972 8.24522 17.4488 7.04286 16.573L3.01168 20.262C5.25301 22.557 8.42398 24 12.0004 24Z" fill="#EA4335"/>
                </svg>
                Sign in with Google
            </button>

            <div class="text-center mt-6 text-sm flex justify-between">
                <a id="auth-toggle-link" href="#/signup" class="text-indigo-600 hover:text-indigo-800 font-medium transition duration-150">
                    Need an account? Sign Up
                </a>
                <a id="auth-reset-link" href="#/reset" class="text-gray-500 hover:text-gray-700 transition duration-150">
                    Forgot Password?
                </a>
            </div>
            
        </div>
    </div>
    
    <!-- *** 3. Read-Only Shared Note Viewer (Independent of App) *** -->
    <div id="shared-viewer-container" class="fixed inset-0 bg-white z-[150] hidden flex-col">
        <div id="shared-viewer-content" class="flex-1 overflow-y-auto p-6 md:p-12 max-w-4xl mx-auto w-full">
            <h1 id="shared-title" class="text-4xl font-extrabold text-gray-900 mb-4"></h1>
            <p id="shared-meta" class="text-sm text-gray-500 border-b pb-4 mb-8"></p>
            <div id="shared-markdown-content" class="markdown-viewer text-gray-700"></div>
        </div>
        <div class="p-4 border-t border-gray-200 text-center bg-gray-50">
            <a href="#/" class="text-indigo-600 hover:text-indigo-800 font-medium">Go back to My Notes App</a>
        </div>
    </div>
    
    <!-- *** 4. Main Application Container *** -->
    <div id="app" class="flex flex-1 overflow-hidden h-screen hidden">
        
        <!-- Note List (Sidebar) -->
        <div id="note-list-container" class="w-full md:w-80 border-r border-gray-200 bg-white flex flex-col transition-transform duration-300 ease-in-out md:static absolute inset-0 z-10">
            <div class="p-4 border-b border-gray-200 shadow-sm flex justify-between items-center">
                <h1 class="text-2xl font-bold text-gray-900">My Notes</h1>
                <div class="flex space-x-2 items-center">
                    <button id="new-note-btn" title="New Note" class="p-2 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition duration-150 active:scale-95">
                        <i data-lucide="plus" class="w-5 h-5"></i>
                    </button>
                    <button id="signout-btn" title="Sign Out" class="p-2 text-gray-500 rounded-full hover:bg-gray-100 transition duration-150 active:scale-95">
                        <i data-lucide="log-out" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Search Input -->
            <div class="p-4 border-b border-gray-100">
                 <div class="relative">
                    <i data-lucide="search" class="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                    <input id="search-input" type="text" placeholder="Search notes..." class="w-full pl-10 pr-4 py-2 border border-gray-200 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-700">
                </div>
            </div>

            <div id="notes-list" class="notes-list flex-1 overflow-y-auto p-2">
                <!-- Notes will be injected here -->
            </div>

            <div class="p-2 text-xs text-gray-500 border-t border-gray-100 text-center">
                <p>User ID: <span id="user-id-display" class="font-mono text-indigo-500 break-all">...</span></p>
            </div>
        </div>

        <!-- Note Editor -->
        <div id="note-editor-container" class="flex-1 flex-col bg-white md:flex hidden">
            <!-- Editor Header -->
            <div class="p-4 border-b border-gray-200 flex justify-between items-center bg-gray-50 shadow-sm">
                <div class="flex items-center space-x-3">
                    <button id="back-to-list-btn" class="text-indigo-600 md:hidden p-2 rounded-lg hover:bg-gray-100 active:bg-gray-200 transition duration-150">
                        <i data-lucide="arrow-left" class="w-5 h-5"></i>
                    </button>
                    <!-- Sidebar Toggle (Desktop/Tablet) -->
                    <button id="toggle-sidebar-btn" title="Toggle Sidebar" class="hidden md:block p-2 text-gray-500 rounded-lg hover:bg-gray-100 active:bg-gray-200 transition duration-150">
                        <i data-lucide="panel-left-close" class="w-5 h-5"></i>
                    </button>
                    
                    <!-- Saving Status Indicator -->
                    <span id="save-status-span" class="text-xs font-medium text-gray-400">Saved</span>
                </div>
                
                <div class="flex items-center space-x-3">
                    <span id="last-edited-time" class="text-xs text-gray-500 hidden md:inline-block">Last edited: --</span>
                    
                    <!-- Markdown Toggle -->
                    <button id="markdown-toggle-btn" title="Toggle Markdown Preview" class="p-2 text-gray-500 rounded-lg hover:bg-gray-100 transition duration-150 active:scale-95">
                        <i data-lucide="eye" class="w-5 h-5"></i>
                    </button>
                    
                    <!-- Share / Unshare Button (Dynamic) -->
                    <button id="dynamic-share-btn" title="Share Note" class="p-2 text-green-600 rounded-lg hover:bg-green-50 transition duration-150 active:scale-95 opacity-50 pointer-events-none">
                        <i data-lucide="share-2" class="w-5 h-5"></i>
                    </button>
                    
                    <button id="delete-note-btn" title="Delete Note" class="p-2 text-red-500 rounded-lg hover:bg-red-50 transition duration-150 active:scale-95 opacity-50 pointer-events-none">
                        <i data-lucide="trash-2" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Editor Body -->
            <div id="editor-body" class="flex-1 overflow-y-auto p-6 space-y-4">
                <input id="note-title" type="text" placeholder="Title your note (supports markdown)" class="w-full text-3xl font-bold border-none focus:ring-0 focus:outline-none placeholder-gray-300 p-0 text-gray-900">
                
                <!-- Raw Markdown Textarea (Default View) -->
                <textarea id="note-content" placeholder="Start typing here... supports **Markdown**!" class="editor-content w-full h-full text-lg border-none focus:ring-0 focus:outline-none resize-none placeholder-gray-400 p-0 text-gray-700"></textarea>

                <!-- Markdown Preview Div (Hidden by Default) -->
                <div id="markdown-preview" class="markdown-viewer w-full h-full text-lg p-0 text-gray-700 hidden"></div>
            </div>
        </div>

        <!-- Empty State for Editor -->
        <div id="empty-editor-state" class="flex-1 flex-col items-center justify-center text-gray-400 p-6 md:flex hidden">
            <i data-lucide="notebook-pen" class="w-16 h-16 mb-4"></i>
            <p class="text-xl font-medium">Select a note or create a new one</p>
        </div>
    </div>

    <!-- Confirmation Modal (REUSABLE) -->
    <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[100]">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-11/12 max-w-sm transform scale-100 transition-transform duration-300">
            <h3 id="modal-title" class="text-xl font-semibold text-gray-800 mb-3">Confirm Action</h3>
            <p id="modal-message" class="text-gray-600 mb-6">Are you sure you want to perform this action?</p>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-100 transition duration-150">Cancel</button>
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition duration-150">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Share URL Modal -->
    <div id="share-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[100]">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-11/12 max-w-lg">
            <h3 class="text-xl font-semibold text-gray-800 mb-3 flex items-center">
                <i data-lucide="link" class="w-5 h-5 mr-2 text-indigo-500"></i> Note Shared Successfully
            </h3>
            <p class="text-gray-600 mb-4">Copy the link below to share this note as a read-only page.</p>
            <div class="flex space-x-2">
                <input id="share-url-input" type="text" readonly class="flex-1 p-3 border border-gray-300 rounded-lg bg-gray-50 text-sm truncate">
                <button id="copy-share-url-btn" class="px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition duration-150 flex items-center">
                    <i data-lucide="copy" class="w-4 h-4 mr-2"></i> Copy
                </button>
            </div>
            <button id="share-modal-close-btn" class="mt-4 w-full py-2 text-gray-600 rounded-lg hover:bg-gray-100 transition duration-150">Close</button>
        </div>
    </div>


    <!-- Firebase Imports and Logic -->
    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, sendPasswordResetEmail, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, query, onSnapshot, addDoc, updateDoc, deleteDoc, serverTimestamp, setLogLevel, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL SETUP ---

        setLogLevel('Debug');

        const PROVIDED_FIREBASE_CONFIG = {
            apiKey: "AIzaSyBqObkmL_fZeeAoaS4weJGx7VU4CskppuQ",
            authDomain: "cloudnote-be55c.firebaseapp.com",
            projectId: "cloudnote-be55c",
            storageBucket: "cloudnote-be55c.firebasestorage.app",
            messagingSenderId: "744575504537",
            appId: "1:744575504537:web:2b76ec5ca81faca23a6808",
            measurementId: "G-LQY0X53JGF"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : PROVIDED_FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;

        // Global Firebase Instances and State
        let firebaseApp = null;
        let db = null;
        let auth = null;
        let googleProvider = null;

        let userId = null;
        let isAuthReady = false; 
        let isNotesLoaded = false; // NEW: Tracks when initial note data is fetched

        let notesData = [];
        let activeNoteId = null;
        let saveTimer = null;
        let authMode = 'signin';
        let unsubscribeNotes = null;
        
        let searchTerm = '';
        let saveStatus = 'Saved';
        let isMarkdownPreview = false;
        let isSidebarOpen = true; 

        // --- DOM Elements ---
        const loadingSpinnerOverlay = document.getElementById('loading-spinner-overlay');
        const appContainer = document.getElementById('app');
        const authOverlay = document.getElementById('auth-overlay');
        const userIdDisplay = document.getElementById('user-id-display');
        const notesListContainer = document.getElementById('note-list-container');
        const notesListElement = document.getElementById('notes-list');
        const newNoteBtn = document.getElementById('new-note-btn');
        const noteTitleInput = document.getElementById('note-title');
        const noteContentTextarea = document.getElementById('note-content');
        const deleteNoteBtn = document.getElementById('delete-note-btn');
        const lastEditedTimeSpan = document.getElementById('last-edited-time');
        const noteEditorContainer = document.getElementById('note-editor-container');
        const emptyEditorState = document.getElementById('empty-editor-state');
        const backToListBtn = document.getElementById('back-to-list-btn');
        const signoutBtn = document.getElementById('signout-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalTitle = document.getElementById('modal-title'); // NEW
        const modalMessage = document.getElementById('modal-message'); // NEW
        const searchInput = document.getElementById('search-input');
        const saveStatusSpan = document.getElementById('save-status-span');
        const markdownPreviewDiv = document.getElementById('markdown-preview');
        const markdownToggleBtn = document.getElementById('markdown-toggle-btn');
        const dynamicShareBtn = document.getElementById('dynamic-share-btn'); // Renamed
        const shareModalOverlay = document.getElementById('share-modal-overlay');
        const shareUrlInput = document.getElementById('share-url-input');
        const copyShareUrlBtn = document.getElementById('copy-share-url-btn');
        const shareModalCloseBtn = document.getElementById('share-modal-close-btn');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');

        // Shared Viewer Elements
        const sharedViewerContainer = document.getElementById('shared-viewer-container');
        const sharedTitle = document.getElementById('shared-title');
        const sharedMeta = document.getElementById('shared-meta');
        const sharedMarkdownContent = document.getElementById('shared-markdown-content');

        // Auth Form Elements (unchanged)
        const authTitle = document.getElementById('auth-title');
        const authMessage = document.getElementById('auth-message');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password');
        const authPrimaryBtn = document.getElementById('auth-primary-btn');
        const authGoogleBtn = document.getElementById('auth-google-btn');
        const authToggleLink = document.getElementById('auth-toggle-link');
        const authResetLink = document.getElementById('auth-reset-link');


        // --- UTILITY & LOADING CONTROL ---
        
        const hideLoadingSpinner = () => {
             // Only hide the spinner if:
             // 1. Auth is ready AND 
             // 2. Either the user is signed out (no notes to load) or the notes have finished loading.
            if (isAuthReady && (!userId || isNotesLoaded)) {
                loadingSpinnerOverlay.classList.add('hidden');
            }
        }
        
        // --- FIREBASE INITIALIZATION & AUTH ---

        const initializeFirebase = () => {
            firebaseApp = initializeApp(firebaseConfig);
            db = getFirestore(firebaseApp);
            auth = getAuth(firebaseApp);
            googleProvider = new GoogleAuthProvider();

            onAuthStateChanged(auth, (user) => {
                isAuthReady = true; 
                
                const hash = window.location.hash;
                const isSharedRoute = hash.startsWith('#/shared/');

                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = userId;
                    
                    authOverlay.classList.add('hidden');
                    sharedViewerContainer.classList.add('hidden'); 
                    appContainer.classList.remove('hidden');

                    startNoteListener(); // Note listener will hide spinner when data arrives
                    handleRouting();
                    
                } else {
                    // User is signed out.
                    userId = null;
                    isNotesLoaded = true; // No notes to load, so consider loading complete
                    notesData = [];
                    setActiveNote(null);

                    if (unsubscribeNotes) {
                        unsubscribeNotes();
                        unsubscribeNotes = null;
                    }

                    if (isSharedRoute) {
                        handleRouting(); 
                    } else {
                        // Default sign out behavior
                        if (!hash.startsWith('#/signup') && !hash.startsWith('#/reset')) {
                            window.location.hash = '#/signin';
                        }
                        authOverlay.classList.remove('hidden');
                        appContainer.classList.add('hidden');
                        sharedViewerContainer.classList.add('hidden');
                        handleRouting(); 
                    }
                    hideLoadingSpinner(); // Hide spinner immediately for unauthenticated users
                }
            });
        };

        // --- ROUTING & UI MANAGEMENT (Unchanged) ---

        const handleRouting = () => {
            let hash = window.location.hash || '#/';
            document.title = "Secure Cloud Notes";
            
            if (!isAuthReady) return;
            
            if (hash.startsWith('#/shared/')) {
                appContainer.classList.add('hidden');
                authOverlay.classList.add('hidden');
                sharedViewerContainer.classList.remove('hidden');
                const sharedId = hash.substring(9);
                renderSharedNote(sharedId);
                return;
            } else {
                 sharedViewerContainer.classList.add('hidden');
            }


            if (userId) {
                authOverlay.classList.add('hidden');
                appContainer.classList.remove('hidden');
                
                if (hash.startsWith('#/notes/')) {
                    const noteId = hash.substring(8);
                    setActiveNote(noteId); 
                } else {
                    setActiveNote(null); 
                }

            } else {
                authOverlay.classList.remove('hidden');
                appContainer.classList.add('hidden');

                if (hash === '#/signup') {
                    setAuthMode('signup');
                } else if (hash === '#/reset') {
                    setAuthMode('reset');
                } else {
                    setAuthMode('signin');
                }
            }
        };

        // --- AUTH LOGIC (omitted for brevity, assume correct functionality) ---
        const setAuthMessage = (message, isError = true) => { /* ... */ };
        const setAuthMode = (mode) => { /* ... */ };
        const handlePrimaryAuthAction = async () => { /* ... */ };
        const handleGoogleSignIn = async () => { /* ... */ };
        const handleSignOut = async () => { /* ... */ };
        // --- END AUTH LOGIC ---

        // --- FIRESTORE OPERATIONS ---

        const getNotesCollectionRef = () => {
            if (!db || !userId) return null;
            const path = `artifacts/${appId}/users/${userId}/notes`;
            return collection(db, path);
        };
        
        const getSharedCollectionRef = () => {
            if (!db) return null;
            const path = `artifacts/${appId}/public/data/shared_notes`;
            return collection(db, path);
        };

        // Real-time listener for notes
        const startNoteListener = () => {
            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;
            
            if (unsubscribeNotes) {
                unsubscribeNotes();
            }

            const q = query(notesRef);

            unsubscribeNotes = onSnapshot(q, (snapshot) => {
                const newNotes = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data(),
                    updatedAt: doc.data().updatedAt?.toDate() || new Date(0)
                }));

                notesData = newNotes;
                renderNoteList();

                if (activeNoteId && !notesData.find(note => note.id === activeNoteId)) {
                    window.location.hash = '#/';
                }
                
                if (activeNoteId) {
                    setActiveNote(activeNoteId);
                }

                // NEW: Hide spinner once notes are loaded for the first time
                if (!isNotesLoaded) {
                    isNotesLoaded = true;
                    hideLoadingSpinner();
                }

            }, (error) => {
                console.error("Error listening to notes:", error);
                setSaveStatus('Error!');
                if (!isNotesLoaded) {
                     isNotesLoaded = true;
                     hideLoadingSpinner();
                }
            });
        };

        const createNewNote = async () => {
            if (!userId) return;

            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;

            try {
                const newNote = {
                    title: "New Note",
                    content: "This note supports **Markdown** formatting.",
                    updatedAt: serverTimestamp(),
                    isShared: false,
                    sharedId: null 
                };
                const docRef = await addDoc(notesRef, newNote);
                window.location.hash = `#/notes/${docRef.id}`;
            } catch (error) {
                console.error("Error creating new note:", error);
            }
        };

        const setSaveStatus = (status) => {
            // ... (unchanged)
            saveStatus = status;
            let text = status;
            let color = 'text-gray-400';

            if (status === 'Typing...') {
                text = 'Typing...';
                color = 'text-gray-500';
            } else if (status === 'Saving...') {
                text = 'Saving...';
                color = 'text-indigo-500';
            } else if (status === 'Saved') {
                text = 'Saved';
                color = 'text-green-600';
            } else if (status === 'Error!') {
                text = 'Error! (Check console)';
                color = 'text-red-500';
            }
            
            saveStatusSpan.textContent = text;
            saveStatusSpan.className = `text-xs font-medium ${color}`;
        };

        const saveActiveNote = async (title, content) => {
            if (!activeNoteId || !userId) return;

            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;
            
            const activeNote = notesData.find(note => note.id === activeNoteId);
            const isShared = activeNote?.isShared === true;

            try {
                setSaveStatus('Saving...');
                const noteDocRef = doc(notesRef, activeNoteId);
                
                const updatePayload = {
                    title: title || '(No Title)',
                    content: content,
                    updatedAt: serverTimestamp()
                };

                await updateDoc(noteDocRef, updatePayload);

                if (isShared && activeNote.sharedId) {
                    // Update the public, read-only copy
                    const sharedRef = getSharedCollectionRef();
                    const sharedDocRef = doc(sharedRef, activeNote.sharedId);
                    await updateDoc(sharedDocRef, updatePayload);
                }
                
                setSaveStatus('Saved');
            } catch (error) {
                console.error("Error saving note:", error);
                setSaveStatus('Error!');
            }
        };
        
        const shareActiveNote = async () => {
            if (!activeNoteId || !userId) return;

            const activeNote = notesData.find(note => note.id === activeNoteId);
            if (!activeNote) return;

            const sharedRef = getSharedCollectionRef();
            const notesRef = getNotesCollectionRef();

            try {
                dynamicShareBtn.disabled = true;
                dynamicShareBtn.title = "Sharing...";

                const baseData = {
                    title: activeNote.title || '(No Title)',
                    content: activeNote.content || '',
                    authorId: userId, // CRITICAL for security rules
                    authorName: auth.currentUser?.email || 'Anonymous',
                    updatedAt: serverTimestamp(),
                };

                let sharedId = activeNote.sharedId;

                if (activeNote.isShared && activeNote.sharedId) {
                    // Already shared, just update the public copy
                    const sharedDocRef = doc(sharedRef, activeNote.sharedId);
                    await updateDoc(sharedDocRef, baseData);
                } else {
                    // Not shared, create new public document
                    const sharedDocRef = await addDoc(sharedRef, baseData);
                    sharedId = sharedDocRef.id;

                    // Update the private note to link it to the public document
                    const noteDocRef = doc(notesRef, activeNoteId);
                    await updateDoc(noteDocRef, {
                        isShared: true,
                        sharedId: sharedId,
                    });
                }
                
                // Construct and display the URL
                const shareUrl = `${window.location.origin}/#/shared/${sharedId}`;
                shareUrlInput.value = shareUrl;
                shareModalOverlay.classList.remove('hidden');
                shareModalOverlay.classList.add('flex');
                
                dynamicShareBtn.disabled = false;
                
                // Active note view updates via onSnapshot
            } catch (error) {
                console.error("Error sharing note:", error);
                // Use custom modal for error
                showConfirmationModal({
                    title: "Sharing Failed",
                    message: `Could not share note due to a permission or network error: ${error.message}`,
                    confirmText: "Close",
                    confirmClass: "bg-indigo-600 hover:bg-indigo-700",
                    onConfirm: hideModal,
                    showCancel: false
                });
                dynamicShareBtn.disabled = false;
            }
        };
        
        const unshareActiveNote = async () => {
             if (!activeNoteId || !userId) return;

            const activeNote = notesData.find(note => note.id === activeNoteId);
            if (!activeNote || !activeNote.isShared || !activeNote.sharedId) return;
            
            const sharedRef = getSharedCollectionRef();
            const notesRef = getNotesCollectionRef();
            const sharedId = activeNote.sharedId;

            try {
                // 1. Delete the public copy
                const sharedDocRef = doc(sharedRef, sharedId);
                await deleteDoc(sharedDocRef);
                
                // 2. Update the private note to unlink it
                const noteDocRef = doc(notesRef, activeNoteId);
                await updateDoc(noteDocRef, {
                    isShared: false,
                    sharedId: null,
                    updatedAt: serverTimestamp()
                });
                
                // Active note view updates via onSnapshot

            } catch (error) {
                console.error("Error unsharing note:", error);
                 showConfirmationModal({
                    title: "Unsharing Failed",
                    message: `Could not remove the public copy: ${error.message}`,
                    confirmText: "Close",
                    confirmClass: "bg-indigo-600 hover:bg-indigo-700",
                    onConfirm: hideModal,
                    showCancel: false
                });
            }
        };


        // --- UI RENDERING & DISPLAY ---
        
        const renderMarkdown = (markdownText) => {
            return marked.parse(markdownText || '');
        }

        const getRelativeTime = (date) => {
            if (!date || date.getTime() === 0) return 'Never';
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " years ago";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " months ago";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " days ago";
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " hours ago";
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " minutes ago";
            if (seconds < 5) return "just now";
            return Math.floor(seconds) + " seconds ago";
        };


        const renderNoteList = () => {
            const term = searchTerm.toLowerCase();
            const filteredNotes = notesData.filter(note => {
                if (!term) return true;
                const titleMatch = note.title?.toLowerCase().includes(term);
                const contentMatch = note.content?.toLowerCase().includes(term);
                return titleMatch || contentMatch;
            });
            
            // Sort by updatedAt, newest first
            filteredNotes.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());

            notesListElement.innerHTML = '';
            
            if (filteredNotes.length === 0) {
                notesListElement.innerHTML = `<p class="p-4 text-center text-gray-400">${searchTerm ? `No notes found matching "${searchTerm}".` : `Create your first note by clicking the '+' button!`}</p>`;
                return;
            }

            filteredNotes.forEach(note => {
                const isActive = note.id === activeNoteId;
                const noteItem = document.createElement('a');
                noteItem.href = `#/notes/${note.id}`;
                noteItem.className = `p-4 mb-2 rounded-xl cursor-pointer block transition duration-150 ${isActive ? 'bg-indigo-100 ring-2 ring-indigo-500 shadow-md' : 'bg-gray-50 hover:bg-gray-100'}`;
                noteItem.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <h3 class="font-semibold ${isActive ? 'text-indigo-800' : 'text-gray-800'} truncate">${note.title || '(No Title)'}</h3>
                        ${note.isShared ? '<i data-lucide="link" class="w-4 h-4 text-green-500 flex-shrink-0" title="Shared"></i>' : ''}
                    </div>
                    <p class="text-xs text-gray-500 mb-1">${getRelativeTime(note.updatedAt)}</p>
                    <p class="text-sm text-gray-600 line-clamp-2">${note.content?.substring(0, 80).replace(/\s+/g, ' ') || 'Empty note...'}</p>
                `;
                notesListElement.appendChild(noteItem);
            });
            lucide.createIcons();
        };
        
        const updateMarkdownView = (content) => {
            markdownPreviewDiv.innerHTML = renderMarkdown(content);
        };

        const toggleMarkdownPreview = (force = null) => {
            isMarkdownPreview = force !== null ? force : !isMarkdownPreview;
            
            if (isMarkdownPreview) {
                noteContentTextarea.classList.add('hidden');
                markdownPreviewDiv.classList.remove('hidden');
                markdownToggleBtn.innerHTML = '<i data-lucide="file-pen" class="w-5 h-5"></i>';
                markdownToggleBtn.title = "Toggle Editing Mode";
                updateMarkdownView(noteContentTextarea.value);
            } else {
                noteContentTextarea.classList.remove('hidden');
                markdownPreviewDiv.classList.add('hidden');
                markdownToggleBtn.innerHTML = '<i data-lucide="eye" class="w-5 h-5"></i>';
                markdownToggleBtn.title = "Toggle Markdown Preview";
                noteContentTextarea.focus();
            }
            lucide.createIcons();
        };

        const toggleSidebar = (force = null) => {
            isSidebarOpen = force !== null ? force : !isSidebarOpen;
            if (isSidebarOpen) {
                notesListContainer.classList.remove('md:w-0', 'w-0', 'hidden');
                notesListContainer.classList.add('md:w-80', 'w-full');
                toggleSidebarBtn.innerHTML = '<i data-lucide="panel-left-close" class="w-5 h-5"></i>';
            } else {
                notesListContainer.classList.add('md:w-0', 'w-0', 'hidden');
                notesListContainer.classList.remove('md:w-80', 'w-full');
                toggleSidebarBtn.innerHTML = '<i data-lucide="panel-left-open" class="w-5 h-5"></i>';
            }
            lucide.createIcons();
        };


        const setActiveNote = (noteId) => {
            activeNoteId = noteId;
            const activeNote = notesData.find(note => note.id === noteId);

            const isMobile = window.innerWidth < 768;

            if (activeNote) {
                // UI Setup
                document.title = (activeNote.title || 'Untitled') + ' | Notes';
                noteEditorContainer.classList.remove('hidden');
                noteEditorContainer.classList.add('flex');
                emptyEditorState.classList.add('hidden');
                
                // Hide list on mobile when editor is open
                if (isMobile) {
                    notesListContainer.classList.add('hidden');
                } else {
                    if (isSidebarOpen) {
                        notesListContainer.classList.remove('hidden');
                    }
                }

                // Data Population
                noteTitleInput.value = activeNote.title || '';
                noteContentTextarea.value = activeNote.content || '';
                lastEditedTimeSpan.textContent = 'Last edited: ' + getRelativeTime(activeNote.updatedAt);
                deleteNoteBtn.classList.remove('opacity-50', 'pointer-events-none');
                
                // Dynamic Share/Unshare Button
                if (activeNote.isShared) {
                    dynamicShareBtn.innerHTML = '<i data-lucide="link-off" class="w-5 h-5"></i>';
                    dynamicShareBtn.title = "Unshare Note (Delete Public Link)";
                    dynamicShareBtn.classList.remove('text-green-600', 'hover:bg-green-50');
                    dynamicShareBtn.classList.add('text-orange-600', 'hover:bg-orange-50');
                    dynamicShareBtn.onclick = () => showConfirmationModal({
                        title: "Confirm Unshare",
                        message: "Are you sure you want to unshare this note? The public link will stop working immediately, and the read-only copy will be permanently deleted.",
                        confirmText: "Unshare",
                        confirmClass: "bg-orange-600 hover:bg-orange-700",
                        onConfirm: unshareActiveNote
                    });
                } else {
                    dynamicShareBtn.innerHTML = '<i data-lucide="share-2" class="w-5 h-5"></i>';
                    dynamicShareBtn.title = "Share Note (Create Public Link)";
                    dynamicShareBtn.classList.remove('text-orange-600', 'hover:bg-orange-50');
                    dynamicShareBtn.classList.add('text-green-600', 'hover:bg-green-50');
                    dynamicShareBtn.onclick = shareActiveNote;
                }
                dynamicShareBtn.classList.remove('opacity-50', 'pointer-events-none');

                setSaveStatus('Saved');
                toggleMarkdownPreview(false);
                noteTitleInput.focus();

            } else {
                // Clear and hide editor
                noteTitleInput.value = '';
                noteContentTextarea.value = '';
                lastEditedTimeSpan.textContent = 'Last edited: --';
                deleteNoteBtn.classList.add('opacity-50', 'pointer-events-none');
                dynamicShareBtn.classList.add('opacity-50', 'pointer-events-none');
                setSaveStatus('');
                
                // Ensure list is visible and editor state is correct
                if (isMobile) {
                    notesListContainer.classList.remove('hidden');
                    noteEditorContainer.classList.add('hidden');
                    emptyEditorState.classList.add('hidden');
                } else {
                    notesListContainer.classList.remove('hidden');
                    noteEditorContainer.classList.add('hidden');
                    emptyEditorState.classList.remove('hidden');
                }
                document.title = "Secure Cloud Notes";
            }

            renderNoteList();
            lucide.createIcons();
        };
        
        const renderSharedNote = async (sharedId) => {
            // ... (unchanged)
            const sharedRef = getSharedCollectionRef();
            const sharedDocRef = doc(sharedRef, sharedId);
            
            sharedTitle.textContent = 'Loading Note...';
            sharedMeta.textContent = '';
            sharedMarkdownContent.innerHTML = '';
            
            try {
                const docSnap = await getDoc(sharedDocRef);
                
                if (docSnap.exists()) {
                    const note = docSnap.data();
                    
                    document.title = (note.title || 'Untitled Shared Note');
                    sharedTitle.textContent = note.title || 'Untitled Note';
                    
                    const timeString = note.updatedAt ? new Date(note.updatedAt.toDate()).toLocaleString() : 'N/A';
                    sharedMeta.textContent = `Shared by ${note.authorName || 'a user'} | Last updated: ${timeString}`;
                    
                    sharedMarkdownContent.innerHTML = renderMarkdown(note.content || '');
                } else {
                    sharedTitle.textContent = 'Note Not Found (404)';
                    sharedMeta.textContent = 'The shared note link is invalid or the note has been deleted by the owner.';
                    sharedMarkdownContent.innerHTML = '';
                }
            } catch (error) {
                console.error("Error loading shared note:", error);
                sharedTitle.textContent = 'An Error Occurred';
                sharedMeta.textContent = 'Could not load note due to a connection error.';
                sharedMarkdownContent.innerHTML = `<p class="text-red-500">${error.message}</p>`;
            } finally {
                // Ensure the spinner is hidden after attempting to load the shared note
                if (loadingSpinnerOverlay.classList.contains('hidden') === false) {
                    loadingSpinnerOverlay.classList.add('hidden');
                }
            }
        };


        // --- REUSABLE MODAL/DIALOG LOGIC ---
        let currentModalAction = null;

        const showConfirmationModal = ({ title, message, confirmText, confirmClass, onConfirm, showCancel = true }) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalConfirmBtn.textContent = confirmText;
            
            // Reset classes and apply new confirmation styling
            modalConfirmBtn.className = "px-4 py-2 text-white rounded-lg transition duration-150 " + (confirmClass || "bg-red-600 hover:bg-red-700");
            
            // Show/hide cancel button
            if (showCancel) {
                modalCancelBtn.classList.remove('hidden');
            } else {
                modalCancelBtn.classList.add('hidden');
            }

            // Set the confirmation action
            currentModalAction = onConfirm;

            modalOverlay.classList.remove('hidden');
            modalOverlay.classList.add('flex');
        };

        const hideModal = () => {
            modalOverlay.classList.add('hidden');
            modalOverlay.classList.remove('flex');
            currentModalAction = null;
        };
        
        // --- EVENT HANDLERS ---

        const setupEventListeners = () => {
            window.addEventListener('hashchange', handleRouting);
            
            // Auth Events (omitted details)
            authPrimaryBtn.addEventListener('click', handlePrimaryAuthAction);
            authGoogleBtn.addEventListener('click', handleGoogleSignIn);

            // Modal Events
            modalCancelBtn.addEventListener('click', hideModal);
            modalConfirmBtn.addEventListener('click', async () => {
                if (currentModalAction) {
                    // Execute the action first, then hide the modal
                    await currentModalAction();
                }
                hideModal();
            });

            // App Events
            signoutBtn.addEventListener('click', handleSignOut);
            newNoteBtn.addEventListener('click', createNewNote);
            searchInput.addEventListener('input', (e) => {
                searchTerm = e.target.value.trim();
                renderNoteList();
            });

            // Delete handler using reusable modal
            deleteNoteBtn.addEventListener('click', () => showConfirmationModal({
                title: "Confirm Deletion",
                message: "Are you sure you want to delete this note? This action cannot be undone.",
                confirmText: "Delete",
                confirmClass: "bg-red-600 hover:bg-red-700",
                onConfirm: async () => {
                     if (!activeNoteId || !userId) return;
                    const notesRef = getNotesCollectionRef();
                    const activeNote = notesData.find(note => note.id === activeNoteId);
                    if (!notesRef || !activeNote) return;

                    try {
                        // If shared, delete the public copy first
                        if (activeNote.isShared && activeNote.sharedId) {
                            const sharedRef = getSharedCollectionRef();
                            await deleteDoc(doc(sharedRef, activeNote.sharedId));
                        }
                        // Delete the private copy
                        await deleteDoc(doc(notesRef, activeNoteId));
                        window.location.hash = '#/';
                    } catch (error) {
                        console.error("Error deleting note:", error);
                        setSaveStatus('Error!');
                    }
                }
            }));

            // Auto-save logic with debounce
            const handleInputChange = () => {
                // ... (unchanged)
                if (!activeNoteId || !userId) return;

                const title = noteTitleInput.value;
                const content = noteContentTextarea.value;
                
                setSaveStatus('Typing...');
                
                if (saveTimer) {
                    clearTimeout(saveTimer);
                }

                saveTimer = setTimeout(() => {
                    saveActiveNote(title, content);
                }, 1000);
                
                if (isMarkdownPreview) {
                    updateMarkdownView(content);
                }
            };

            noteTitleInput.addEventListener('input', handleInputChange);
            noteContentTextarea.addEventListener('input', handleInputChange);

            // Feature Button Handlers
            toggleSidebarBtn.addEventListener('click', toggleSidebar);
            markdownToggleBtn.addEventListener('click', () => toggleMarkdownPreview());

            // Share Modal Handlers
            shareModalCloseBtn.addEventListener('click', () => {
                shareModalOverlay.classList.add('hidden');
                shareModalOverlay.classList.remove('flex');
            });
            copyShareUrlBtn.addEventListener('click', () => {
                shareUrlInput.select();
                shareUrlInput.setSelectionRange(0, 99999); 
                document.execCommand('copy');
                copyShareUrlBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyShareUrlBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4 mr-2"></i> Copy';
                    lucide.createIcons();
                }, 2000);
            });


            // Mobile back button routes to list
            backToListBtn.addEventListener('click', () => {
                window.location.hash = '#/';
            });

            // Handle window resize for responsive layout
            window.addEventListener('resize', () => {
                // Force sidebar visibility update on resize to handle mobile/desktop breakpoint change
                const isMobile = window.innerWidth < 768;
                if (isMobile) {
                    if (activeNoteId) {
                        notesListContainer.classList.add('hidden');
                    } else {
                        notesListContainer.classList.remove('hidden');
                    }
                } else {
                     if (isSidebarOpen) {
                         notesListContainer.classList.remove('hidden');
                     }
                }
            });
        };


        // --- APPLICATION START ---

        document.addEventListener('DOMContentLoaded', () => {
            if (!window.location.hash) {
                window.location.hash = '#/';
            }
            
            lucide.createIcons();
            setupEventListeners();
            initializeFirebase();
        });

    </script>
</body>
</html>

