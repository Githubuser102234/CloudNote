<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Cloud Notes</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Load Lucide icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Load Marked.js for Markdown Rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Apply Inter font family */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Dark Mode Colors FIXES (COMPREHENSIVE) --- */
        body.dark {
            background-color: #0d1117; /* Base Background (GitHub dark theme style) */
            color: #c9d1d9; /* Light gray text */
        }

        /* Primary Containers (Sidebar, Modals, Shared Viewer, Auth Box) */
        body.dark #note-list-container, 
        body.dark #auth-overlay > div, 
        body.dark #shared-viewer-container,
        body.dark #modal-overlay > div, 
        body.dark #share-modal-overlay > div,
        body.dark #note-editor-container { /* Explicitly target editor */
            background-color: #161b22; 
            border-color: #30363d; 
            color: #c9d1d9;
        }
        
        /* Editor Header and Footers (secondary BG) */
        body.dark #note-editor-container > div:first-child,
        body.dark #note-list-container > div:first-child,
        body.dark #note-list-container > div:last-child {
             background-color: #161b22; 
             border-color: #30363d;
        }
        
        body.dark #auth-overlay {
            background-color: #0d1117;
        }

        /* Note list item default state */
        body.dark .notes-list a:not(.active), 
        body.dark #empty-editor-state,
        body.dark #search-input {
            background-color: #161b22;
        }
        
        body.dark .notes-list a:not(.active):hover {
            background-color: #30363d; /* Dark hover */
        }

        /* Active note contrast FIX */
        body.dark .notes-list a.active {
            background-color: #4f46e520; 
            box-shadow: 0 0 0 2px #4f46e5;
        }
        body.dark .notes-list a.active h3 {
             color: #c7d2fe; 
        }
        body.dark .notes-list a.active p {
             color: #9ca3af; 
        }

        /* General element color overrides for dark mode */
        body.dark .border-gray-200 { border-color: #30363d; }
        body.dark .bg-gray-50 { background-color: #161b22; } /* Corrected for editor header */
        body.dark .text-gray-900 { color: #f3f4f6; }
        body.dark .text-gray-700 { color: #c9d1d9; }
        body.dark .text-gray-600 { color: #9ca3af; }
        body.dark .text-gray-500 { color: #6b7280; }
        body.dark .text-gray-400 { color: #4b5563; }
        
        /* Input & Textarea FIX: Ensure full override */
        body.dark input, 
        body.dark textarea {
            background-color: #161b22 !important; 
            border-color: #30363d !important; 
            color: #f3f4f6 !important; 
        }
        body.dark input::placeholder, 
        body.dark textarea::placeholder {
            color: #6b7280; 
        }
        body.dark input:focus, 
        body.dark textarea:focus {
            background-color: #161b22 !important;
        }
        
        /* Dark mode markdown styling */
        body.dark .markdown-viewer pre {
            background-color: #0d1117; 
            border: 1px solid #30363d;
        }
        body.dark .markdown-viewer code {
            background-color: #30363d;
            color: #c9d1d9;
        }
        
        /* Share URL Input Fix */
        body.dark #share-url-input {
            background-color: #30363d !important;
            border-color: #4b5563 !important;
            color: #f3f4f6 !important;
        }
        
        /* Tag Pill Styling */
        .tag-pill {
            display: inline-flex;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 9999px;
            font-weight: 500;
            margin-right: 4px;
            background-color: #e0e7ff; 
            color: #4f46e5; 
        }
        body.dark .tag-pill {
            background-color: #374151; 
            color: #c7d2fe; 
        }

        /* Custom scrollbar for better aesthetics */
        .notes-list::-webkit-scrollbar, .editor-content::-webkit-scrollbar, .markdown-viewer::-webkit-scrollbar {
            width: 6px;
        }
        .notes-list::-webkit-scrollbar-thumb, .editor-content::-webkit-scrollbar-thumb, .markdown-viewer::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        .notes-list::-webkit-scrollbar-thumb:hover, .editor-content::-webkit-scrollbar-thumb:hover, .markdown-viewer::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        body.dark .notes-list::-webkit-scrollbar-thumb, body.dark .editor-content::-webkit-scrollbar-thumb, body.dark .markdown-viewer::-webkit-scrollbar-thumb {
            background: #4b5563;
        }
        body.dark .notes-list::-webkit-scrollbar-thumb:hover, body.dark .editor-content::-webkit-scrollbar-thumb:hover, body.dark .markdown-viewer::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        
        /* Markdown Styling - Ensure good readability */
        .markdown-viewer {
            line-height: 1.75;
        }
        .markdown-viewer h1, .markdown-viewer h2, .markdown-viewer h3 {
            font-weight: 700;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        .markdown-viewer p {
            margin-bottom: 1em;
        }
        .markdown-viewer pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-size: 0.875rem;
        }
        .markdown-viewer code {
            font-family: monospace;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        /* Ensure editor content takes full available height */
        #note-content {
            min-height: calc(100% - 150px); 
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col">

    <!-- *** 1. Loading Spinner Overlay *** -->
    <div id="loading-spinner-overlay" class="fixed inset-0 bg-gray-50 flex items-center justify-center z-[300]">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-4 border-t-indigo-500 border-gray-200 mb-3"></div>
            <p class="text-indigo-600 font-medium">Initializing Application...</p>
        </div>
    </div>

    <!-- *** 2. Auth Modal/Overlay *** -->
    <div id="auth-overlay" class="fixed inset-0 bg-white flex items-center justify-center z-[200] hidden">
        <div class="bg-white p-6 md:p-10 rounded-xl shadow-2xl w-11/12 max-w-sm transform transition-all duration-300 border border-gray-100">
            <h3 id="auth-title" class="text-3xl font-bold text-gray-900 mb-6 text-center">Sign In</h3>
            
            <div id="auth-message" class="text-sm text-center text-red-500 mb-4 hidden"></div>

            <input id="auth-email" type="email" placeholder="Email" class="w-full mb-3 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">
            <input id="auth-password" type="password" placeholder="Password" class="w-full mb-4 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150">

            <button id="auth-primary-btn" class="w-full py-3 mb-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 active:scale-[.99]">
                Sign In
            </button>
            
            <div class="relative flex items-center justify-center mb-4">
                <div class="flex-grow border-t border-gray-200"></div>
                <span class="flex-shrink mx-4 text-gray-400 text-sm">OR</span>
                <div class="flex-grow border-t border-gray-200"></div>
            </div>

            <button id="auth-google-btn" class="w-full py-3 flex items-center justify-center space-x-2 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-50 transition duration-150 active:scale-[.99]">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12.0004 0C8.42398 0 5.25301 1.44299 3.01168 3.73802L7.04286 7.42701C8.24522 6.55118 9.94729 6.00282 12.0004 6.00282C13.8427 6.00282 15.6548 6.6416 17.0628 7.74758L21.0939 4.05859C18.8526 1.76356 15.6816 0.000183105 12.0004 0.000183105V0ZM2.75 6.00004C1.94297 7.2185 1.50005 8.57024 1.50005 9.99999C1.50005 11.4297 1.94297 12.7815 2.75 14L6.78119 10.311C6.78119 10.311 6.81261 10.0381 6.81261 9.99999C6.81261 9.96188 6.78119 9.68903 6.78119 9.68903L2.75 6.00004ZM12.0004 24C15.6816 24 18.8526 22.2364 21.0939 19.9414L17.0628 16.2524C15.6548 17.3584 13.8427 17.9972 12.0004 17.9972C9.94729 17.9972 8.24522 17.4488 7.04286 16.573L3.01168 20.262C5.25301 22.557 8.42398 24 12.0004 24Z" fill="#EA4335"/>
                </svg>
                Sign in with Google
            </button>

            <div class="text-center mt-6 text-sm flex justify-between">
                <a id="auth-toggle-link" href="#/signup" class="text-indigo-600 hover:text-indigo-800 font-medium transition duration-150">
                    Need an account? Sign Up
                </a>
                <a id="auth-reset-link" href="#/reset" class="text-gray-500 hover:text-gray-700 transition duration-150">
                    Forgot Password?
                </a>
            </div>
            
        </div>
    </div>
    
    <!-- *** 3. Read-Only Shared Note Viewer *** -->
    <div id="shared-viewer-container" class="fixed inset-0 bg-white z-[150] hidden flex-col">
        <div id="shared-viewer-content" class="flex-1 overflow-y-auto p-6 md:p-12 max-w-4xl mx-auto w-full">
            <h1 id="shared-title" class="text-4xl font-extrabold text-gray-900 mb-4"></h1>
            <div id="shared-meta" class="text-sm text-gray-500 border-b pb-4 mb-8"></div>
            <div id="shared-markdown-content" class="markdown-viewer text-gray-700"></div>
        </div>
        <div class="p-4 border-t border-gray-200 text-center bg-gray-50 flex flex-col md:flex-row md:justify-center md:space-x-4">
             <button id="shared-edit-btn" class="hidden py-2 px-4 mb-2 md:mb-0 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition duration-150 active:scale-[.99]">
                <i data-lucide="file-pen" class="w-4 h-4 mr-1 inline-block"></i> Edit My Note
            </button>
            <a href="#/" class="py-2 px-4 text-indigo-600 hover:text-indigo-800 font-medium">Go back to My Notes App</a>
        </div>
    </div>
    
    <!-- *** 4. Main Application Container *** -->
    <div id="app" class="flex flex-1 overflow-hidden h-screen hidden">
        
        <!-- Note List (Sidebar) -->
        <div id="note-list-container" class="w-full md:w-80 border-r border-gray-200 bg-white flex flex-col transition-transform duration-300 ease-in-out absolute inset-0 z-10 md:static">
            <div class="p-4 border-b border-gray-200 shadow-sm flex justify-between items-center bg-white">
                <h1 class="text-2xl font-bold text-gray-900">My Notes</h1>
                <div class="flex space-x-2 items-center">
                    <!-- Dark Mode Toggle -->
                    <button id="dark-mode-toggle" title="Toggle Dark Mode" class="p-2 text-gray-500 rounded-full hover:bg-gray-100 transition duration-150 active:scale-95">
                        <i data-lucide="sun" class="w-5 h-5"></i>
                    </button>
                    <button id="new-note-btn" title="New Note" class="p-2 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 transition duration-150 active:scale-95">
                        <i data-lucide="plus" class="w-5 h-5"></i>
                    </button>
                    <button id="signout-btn" title="Sign Out" class="p-2 text-gray-500 rounded-full hover:bg-gray-100 transition duration-150 active:scale-95">
                        <i data-lucide="log-out" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Search Input -->
            <div class="p-4 border-b border-gray-100 bg-white">
                 <div class="relative">
                    <i id="search-icon" data-lucide="search" class="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                    <input id="search-input" type="text" placeholder="Search notes, content, or #tag..." class="w-full pl-10 pr-4 py-2 border border-gray-200 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 text-gray-700">
                </div>
            </div>

            <div id="notes-list" class="notes-list flex-1 overflow-y-auto p-2">
                <!-- Notes will be injected here -->
            </div>

            <div class="p-2 text-xs text-gray-500 border-t border-gray-100 text-center bg-white">
                <p>User ID: <span id="user-id-display" class="font-mono text-indigo-500 break-all">...</span></p>
            </div>
        </div>

        <!-- Note Editor -->
        <div id="note-editor-container" class="flex-1 flex-col bg-white hidden md:flex">
            <!-- Editor Header (Sticky) -->
            <div class="sticky top-0 z-10 p-4 border-b border-gray-200 flex justify-between items-center bg-gray-50 shadow-md">
                <div class="flex items-center space-x-3">
                    <!-- Back to list button (Mobile only) -->
                    <button id="back-to-list-btn" title="Back to Notes" class="text-indigo-600 md:hidden p-2 rounded-lg hover:bg-gray-100 active:bg-gray-200 transition duration-150">
                        <i data-lucide="arrow-left" class="w-5 h-5"></i>
                    </button>
                    <!-- Sidebar Toggle (Desktop/Tablet) -->
                    <button id="toggle-sidebar-btn" title="Toggle Sidebar" class="hidden md:block p-2 text-gray-500 rounded-lg hover:bg-gray-100 active:bg-gray-200 transition duration-150">
                        <i data-lucide="panel-left-close" class="w-5 h-5"></i>
                    </button>
                    
                    <!-- Saving Status Indicator -->
                    <span id="save-status-span" class="text-xs font-medium text-gray-400">Saved</span>
                </div>
                
                <div class="flex items-center space-x-3">
                    <span id="last-edited-time" class="text-xs text-gray-500 hidden md:inline-block">Last edited: --</span>
                    
                    <!-- Markdown Toggle -->
                    <button id="markdown-toggle-btn" title="Toggle Markdown Preview" class="p-2 text-gray-500 rounded-lg hover:bg-gray-100 transition duration-150 active:scale-95">
                        <i data-lucide="eye" class="w-5 h-5"></i>
                    </button>
                    
                    <!-- Share / Unshare Button (Dynamic) -->
                    <button id="dynamic-share-btn" title="Share Note" class="p-2 text-green-600 rounded-lg hover:bg-green-50 transition duration-150 active:scale-95 opacity-50 pointer-events-none">
                        <i data-lucide="share-2" class="w-5 h-5"></i>
                    </button>
                    
                    <button id="delete-note-btn" title="Delete Note" class="p-2 text-red-500 rounded-lg hover:bg-red-50 transition duration-150 active:scale-95 opacity-50 pointer-events-none">
                        <i data-lucide="trash-2" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

            <!-- Editor Body -->
            <div id="editor-body" class="flex-1 flex flex-col overflow-y-auto p-6 space-y-4">
                <input id="note-title" type="text" placeholder="Title your note (supports markdown)" class="w-full text-3xl font-bold border-none focus:ring-0 focus:outline-none placeholder-gray-300 p-0 text-gray-900 bg-transparent">
                
                <!-- Tags Input -->
                <input id="note-tags-input" type="text" placeholder="Tags (e.g., work, project, #idea) - Max 10" class="w-full text-sm border-none focus:ring-0 focus:outline-none placeholder-gray-400 p-0 text-gray-500 border-b pb-2 bg-transparent">

                <!-- Raw Markdown Textarea (Default View) -->
                <textarea id="note-content" placeholder="Start typing here... supports **Markdown**!" class="editor-content w-full flex-1 text-lg border-none focus:ring-0 focus:outline-none resize-none placeholder-gray-400 p-0 text-gray-700 bg-transparent"></textarea>

                <!-- Markdown Preview Div (Hidden by Default) -->
                <div id="markdown-preview" class="markdown-viewer w-full flex-1 text-lg p-0 text-gray-700 hidden"></div>
            </div>
        </div>

        <!-- Empty State for Editor -->
        <div id="empty-editor-state" class="flex-1 flex-col items-center justify-center text-gray-400 p-6 hidden md:flex">
            <i data-lucide="notebook-pen" class="w-16 h-16 mb-4"></i>
            <p class="text-xl font-medium">Select a note or create a new one</p>
        </div>
    </div>

    <!-- Confirmation Modal (REUSABLE) -->
    <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[100]">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-11/12 max-w-sm transform scale-100 transition-transform duration-300">
            <h3 id="modal-title" class="text-xl font-semibold text-gray-800 mb-3">Confirm Action</h3>
            <p id="modal-message" class="text-gray-600 mb-6">Are you sure you want to perform this action?</p>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 text-gray-600 rounded-lg hover:bg-gray-100 transition duration-150">Cancel</button>
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition duration-150">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Share URL Modal -->
    <div id="share-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[100]">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-11/12 max-w-lg">
            <h3 class="text-xl font-semibold text-gray-800 mb-3 flex items-center">
                <i data-lucide="link" class="w-5 h-5 mr-2 text-indigo-500"></i> Note Shared Successfully
            </h3>
            <p class="text-gray-600 mb-4">Copy the link below to share this note as a read-only page. Any changes you make will update this link instantly.</p>
            <div class="flex space-x-2">
                <input id="share-url-input" type="text" readonly class="flex-1 p-3 border border-gray-300 rounded-lg bg-gray-50 text-sm truncate text-gray-900">
                <button id="copy-share-url-btn" class="px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition duration-150 flex items-center">
                    <i data-lucide="copy" class="w-4 h-4 mr-2"></i> Copy
                </button>
            </div>
            <button id="share-modal-close-btn" class="mt-4 w-full py-2 text-gray-600 rounded-lg hover:bg-gray-100 transition duration-150">Close</button>
        </div>
    </div>


    <!-- Firebase Imports and Logic -->
    <script type="module">
        // Import Firebase SDKs
        // FIX: Added getDocs import here
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, sendPasswordResetEmail, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, query, onSnapshot, addDoc, updateDoc, deleteDoc, serverTimestamp, setLogLevel, getDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL SETUP ---

        setLogLevel('Debug');

        // Note: Using a mock config since this is hosted on GitHub Pages
        const PROVIDED_FIREBASE_CONFIG = {
            apiKey: "AIzaSyBqObkmL_fZeeAoaS4weJGx7VU4CskppuQ",
            authDomain: "cloudnote-be55c.firebaseapp.com",
            projectId: "cloudnote-be55c",
            storageBucket: "cloudnote-be55c.firebasestorage.app",
            messagingSenderId: "744575504537",
            appId: "1:744575504537:web:2b76ec5ca81faca23a6808",
            measurementId: "G-LQY0X53JGF"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : PROVIDED_FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;

        // Global Firebase Instances and State
        let firebaseApp = null;
        let db = null;
        let auth = null;
        let googleProvider = null;

        let userId = null;
        let isAuthReady = false; 
        let isNotesLoaded = false; 
        let isDarkMode = false; 

        let notesData = [];
        let activeNoteId = null;
        let saveTimer = null;
        let authMode = 'signin';
        let unsubscribeNotes = null;
        
        let searchTerm = '';
        let saveStatus = 'Saved';
        let isMarkdownPreview = false;
        let isSidebarOpen = true; // Default state for desktop

        // --- DOM Elements ---
        const bodyElement = document.body;
        const loadingSpinnerOverlay = document.getElementById('loading-spinner-overlay');
        const appContainer = document.getElementById('app');
        const authOverlay = document.getElementById('auth-overlay');
        const userIdDisplay = document.getElementById('user-id-display');
        const notesListContainer = document.getElementById('note-list-container');
        const notesListElement = document.getElementById('notes-list');
        const newNoteBtn = document.getElementById('new-note-btn');
        const noteTitleInput = document.getElementById('note-title');
        const noteTagsInput = document.getElementById('note-tags-input');
        const noteContentTextarea = document.getElementById('note-content');
        const deleteNoteBtn = document.getElementById('delete-note-btn');
        const lastEditedTimeSpan = document.getElementById('last-edited-time');
        const noteEditorContainer = document.getElementById('note-editor-container');
        const emptyEditorState = document.getElementById('empty-editor-state');
        const backToListBtn = document.getElementById('back-to-list-btn');
        const signoutBtn = document.getElementById('signout-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const searchInput = document.getElementById('search-input');
        const searchIcon = document.getElementById('search-icon');
        const saveStatusSpan = document.getElementById('save-status-span');
        const markdownPreviewDiv = document.getElementById('markdown-preview');
        const markdownToggleBtn = document.getElementById('markdown-toggle-btn');
        const dynamicShareBtn = document.getElementById('dynamic-share-btn');
        const shareModalOverlay = document.getElementById('share-modal-overlay');
        const shareUrlInput = document.getElementById('share-url-input');
        const copyShareUrlBtn = document.getElementById('copy-share-url-btn');
        const shareModalCloseBtn = document.getElementById('share-modal-close-btn');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
        const darkModeToggleBtn = document.getElementById('dark-mode-toggle'); 

        // Shared Viewer Elements
        const sharedViewerContainer = document.getElementById('shared-viewer-container');
        const sharedTitle = document.getElementById('shared-title');
        const sharedMeta = document.getElementById('shared-meta');
        const sharedMarkdownContent = document.getElementById('shared-markdown-content');
        const sharedEditBtn = document.getElementById('shared-edit-btn');

        // Auth Form Elements
        const authTitle = document.getElementById('auth-title');
        const authMessage = document.getElementById('auth-message');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password');
        const authPrimaryBtn = document.getElementById('auth-primary-btn');
        const authGoogleBtn = document.getElementById('auth-google-btn');
        const authToggleLink = document.getElementById('auth-toggle-link');
        const authResetLink = document.getElementById('auth-reset-link');


        // --- UTILITY & LOADING CONTROL ---
        
        const isMobileView = () => window.innerWidth < 768;

        const hideLoadingSpinner = () => {
            if (isAuthReady && (isNotesLoaded || window.location.hash.startsWith('#/shared/'))) {
                loadingSpinnerOverlay.classList.add('hidden');
            }
        }
        
        const parseTags = (tagString) => {
            if (!tagString) return [];
            // Remove hashtags before splitting, then trim/filter
            return tagString.split(',')
                .map(tag => tag.replace(/#/g, '').trim().toLowerCase()) 
                .filter(tag => tag.length > 0)
                .slice(0, 10); // Limit to 10 tags
        };

        const tagsArrayToString = (tagsArray) => {
            if (!tagsArray || tagsArray.length === 0) return '';
            return tagsArray.join(', ');
        };
        
        // Helper to strip markdown for list preview
        const stripMarkdown = (markdownText) => {
            if (!markdownText) return '';
            let stripped = markdownText
                .replace(/([#*-])/g, '') 
                .replace(/(\[[^\]]*\]\([^\)]*\))/g, '') 
                .replace(/(\n+)/g, ' ') 
                .trim();
            return stripped.substring(0, 100).trim(); 
        };


        // --- DARK MODE LOGIC (Theme Persistence Fix) ---
        const initializeDarkMode = () => {
            const savedMode = localStorage.getItem('notesAppDarkMode');
            
            if (savedMode === 'true') {
                isDarkMode = true;
            } else if (savedMode === 'false') {
                isDarkMode = false;
            } else {
                isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            }
            
            applyDarkMode(isDarkMode);
            // Ensure spinner background matches the theme
            const loadingBgClass = isDarkMode ? 'bg-[#111827]' : 'bg-gray-50';
            loadingSpinnerOverlay.classList.remove('bg-gray-50');
            loadingSpinnerOverlay.classList.add(loadingBgClass);
        };

        const applyDarkMode = (enabled) => {
            isDarkMode = enabled;
            if (isDarkMode) {
                bodyElement.classList.add('dark');
                darkModeToggleBtn.innerHTML = '<i data-lucide="moon" class="w-5 h-5"></i>';
                darkModeToggleBtn.title = "Toggle Light Mode";
            } else {
                bodyElement.classList.remove('dark');
                darkModeToggleBtn.innerHTML = '<i data-lucide="sun" class="w-5 h-5"></i>';
                darkModeToggleBtn.title = "Toggle Dark Mode";
            }
            localStorage.setItem('notesAppDarkMode', isDarkMode);
            lucide.createIcons();
            if(userId) renderNoteList();
            if(activeNoteId) setActiveNote(activeNoteId, false); // Re-render editor styles
        };

        const toggleDarkMode = () => {
            applyDarkMode(!isDarkMode);
        };


        // --- FIREBASE INITIALIZATION & AUTH ---

        const initializeFirebase = () => {
            firebaseApp = initializeApp(firebaseConfig);
            db = getFirestore(firebaseApp);
            auth = getAuth(firebaseApp);
            googleProvider = new GoogleAuthProvider();

            onAuthStateChanged(auth, (user) => {
                isAuthReady = true; 
                
                const hash = window.location.hash;
                const isSharedRoute = hash.startsWith('#/shared/');

                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = userId;
                    
                    authOverlay.classList.add('hidden');
                    sharedViewerContainer.classList.add('hidden'); 
                    appContainer.classList.remove('hidden');

                    startNoteListener(); 
                    
                } else {
                    // User is signed out.
                    userId = null;
                    isNotesLoaded = true; // No notes to load
                    notesData = [];
                    setActiveNote(null);

                    if (unsubscribeNotes) {
                        unsubscribeNotes();
                        unsubscribeNotes = null;
                    }

                    if (!isSharedRoute) {
                        // Default sign out behavior: force signin route
                        if (!hash.startsWith('#/signup') && !hash.startsWith('#/reset')) {
                            window.location.hash = '#/signin';
                        }
                    }
                }
                
                handleRouting();
            });
        };
        
        // --- AUTH LOGIC ---

        const setAuthMessage = (message, isError = true) => {
            authMessage.textContent = message;
            authMessage.classList.remove('hidden', isError ? 'text-green-600' : 'text-red-500');
            authMessage.classList.add(isError ? 'text-red-500' : 'text-green-600');
        };

        const setAuthMode = (mode) => {
            authMode = mode;
            authEmailInput.value = '';
            authPasswordInput.value = '';
            authMessage.classList.add('hidden');
            
            if (mode === 'signin') {
                authTitle.textContent = 'Sign In to Your Notes';
                authPrimaryBtn.textContent = 'Sign In';
                authToggleLink.href = '#/signup';
                authToggleLink.textContent = 'Need an account? Sign Up';
                authResetLink.classList.remove('hidden');
                authPasswordInput.classList.remove('hidden');
                authPasswordInput.type = 'password';
            } else if (mode === 'signup') {
                authTitle.textContent = 'Create an Account';
                authPrimaryBtn.textContent = 'Sign Up';
                authToggleLink.href = '#/signin';
                authToggleLink.textContent = 'Already have an account? Sign In';
                authResetLink.classList.add('hidden');
                authPasswordInput.classList.remove('hidden');
                authPasswordInput.type = 'password';
            } else if (mode === 'reset') {
                authTitle.textContent = 'Reset Password';
                authPrimaryBtn.textContent = 'Send Reset Email';
                authToggleLink.href = '#/signin';
                authToggleLink.textContent = 'Go back to Sign In';
                authResetLink.classList.add('hidden');
                authPasswordInput.classList.add('hidden');
            }
            authPrimaryBtn.disabled = false;
        };

        const handlePrimaryAuthAction = async () => {
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();
            const btnText = authPrimaryBtn.textContent;
            authPrimaryBtn.disabled = true;
            authPrimaryBtn.textContent = 'Loading...';

            try {
                if (authMode === 'signin') {
                    await signInWithEmailAndPassword(auth, email, password);
                } else if (authMode === 'signup') {
                    await createUserWithEmailAndPassword(auth, email, password);
                } else if (authMode === 'reset') {
                    if (!email) throw new Error('Email is required for password reset.');
                    await sendPasswordResetEmail(auth, email);
                    setAuthMessage('Password reset email sent! Check your inbox.', false);
                    authPrimaryBtn.textContent = btnText;
                    authPrimaryBtn.disabled = false;
                    return; 
                }
            } catch (error) {
                let message = "An unknown error occurred.";
                if (error.code) {
                    switch (error.code) {
                        case 'auth/invalid-email': message = 'Invalid email format.'; break;
                        case 'auth/user-not-found': message = 'User not found.'; break;
                        case 'auth/wrong-password': message = 'Invalid password.'; break;
                        case 'auth/email-already-in-use': message = 'Email already in use.'; break;
                        case 'auth/weak-password': message = 'Password should be at least 6 characters.'; break;
                        case 'auth/missing-email': 
                        case 'auth/invalid-credential': 
                            message = 'Email and password are required.'; break;
                        default: message = `Error: ${error.message}`;
                    }
                } else {
                    message = error.message;
                }
                setAuthMessage(message);
                authPrimaryBtn.textContent = btnText;
                authPrimaryBtn.disabled = false;
            }
        };

        const handleGoogleSignIn = async () => {
            authGoogleBtn.disabled = true;
            authGoogleBtn.textContent = 'Loading...';
            try {
                await signInWithPopup(auth, googleProvider);
            } catch (error) {
                console.error("Google Sign In Error:", error);
                setAuthMessage('Google sign-in failed.', true);
                authGoogleBtn.textContent = 'Sign in with Google';
                authGoogleBtn.disabled = false;
            }
        };

        const handleSignOut = async () => {
            signoutBtn.disabled = true;
            try {
                activeNoteId = null; 
                window.location.hash = '#/';
                await signOut(auth);
                signoutBtn.disabled = false;
            } catch (error) {
                console.error("Sign Out Error:", error);
                showConfirmationModal({
                    title: "Sign Out Failed",
                    message: `Failed to sign out: ${error.message}`,
                    confirmText: "Close",
                    confirmClass: "bg-indigo-600 hover:bg-indigo-700",
                    onConfirm: hideModal,
                    showCancel: false
                });
                signoutBtn.disabled = false;
            }
        };

        // --- ROUTING & UI MANAGEMENT ---

        const handleRouting = () => {
            let hash = window.location.hash || '#/';
            document.title = "Secure Cloud Notes";
            
            if (!isAuthReady) return; 
            
            const isSharedRoute = hash.startsWith('#/shared/');

            if (isSharedRoute) {
                appContainer.classList.add('hidden');
                authOverlay.classList.add('hidden');
                sharedViewerContainer.classList.remove('hidden');
                const sharedId = hash.substring(9);
                renderSharedNote(sharedId);
                hideLoadingSpinner(); 
                return;
            } else {
                 sharedViewerContainer.classList.add('hidden');
            }


            if (userId) {
                // AUTHENTICATED USER FLOW
                authOverlay.classList.add('hidden');
                appContainer.classList.remove('hidden');
                
                const isNoteRoute = hash.startsWith('#/notes/');
                
                if (isNoteRoute) {
                    const noteId = hash.substring(8);
                    setActiveNote(noteId); 
                    // Mobile UX: If note selected, hide sidebar
                    if (isMobileView()) {
                        notesListContainer.classList.add('hidden');
                        noteEditorContainer.classList.remove('hidden', 'md:hidden');
                        noteEditorContainer.classList.add('flex');
                    }
                } else {
                    setActiveNote(null); 
                    // Mobile UX: Show sidebar, hide editor
                    if (isMobileView()) {
                        notesListContainer.classList.remove('hidden');
                        noteEditorContainer.classList.add('hidden');
                        emptyEditorState.classList.add('hidden');
                    }
                }

            } else {
                // UNAUTHENTICATED USER FLOW
                appContainer.classList.add('hidden');
                authOverlay.classList.remove('hidden');

                if (hash === '#/signup') {
                    setAuthMode('signup');
                } else if (hash === '#/reset') {
                    setAuthMode('reset');
                } else {
                    setAuthMode('signin');
                    window.location.hash = '#/signin'; 
                }
            }
            
            hideLoadingSpinner(); 
            lucide.createIcons();
        };

        // --- FIRESTORE OPERATIONS ---

        const getNotesCollectionRef = () => {
            if (!db || !userId) return null;
            const effectiveAppId = firebaseConfig.projectId; 
            // Private Data Path
            const path = `artifacts/${effectiveAppId}/users/${userId}/notes`;
            return collection(db, path);
        };
        
        const getSharedCollectionRef = () => {
            if (!db) return null;
            const effectiveAppId = firebaseConfig.projectId;
            // Public Data Path
            const path = `artifacts/${effectiveAppId}/public/data/shared_notes`;
            return collection(db, path);
        };

        const startNoteListener = () => {
            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;
            
            if (unsubscribeNotes) {
                unsubscribeNotes();
            }

            const q = query(notesRef);

            unsubscribeNotes = onSnapshot(q, (snapshot) => {
                const newNotes = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data(),
                    // Bug fix: ensure tags is always an array
                    tags: Array.isArray(doc.data().tags) ? doc.data().tags : [], 
                    // Use a safe date parsing
                    updatedAt: doc.data().updatedAt?.toDate() || new Date(0)
                }));

                notesData = newNotes;
                renderNoteList();

                // Check active note status
                if (activeNoteId) {
                    const updatedNote = notesData.find(note => note.id === activeNoteId);
                    if (!updatedNote) {
                        // Active note was deleted
                        window.location.hash = '#/';
                    } else {
                        // Update editor content in case of external modification
                        setActiveNote(activeNoteId, false); 
                    }
                }
                
                if (!isNotesLoaded) {
                    isNotesLoaded = true;
                    hideLoadingSpinner();
                }

            }, (error) => {
                console.error("Error listening to notes:", error);
                setSaveStatus('Error!');
                if (!isNotesLoaded) {
                     isNotesLoaded = true;
                     hideLoadingSpinner();
                }
            });
        };

        const createNewNote = async () => {
            if (!userId) return;

            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;

            try {
                const newNote = {
                    title: "New Note",
                    content: "This note supports **Markdown** formatting.",
                    tags: [], 
                    updatedAt: serverTimestamp(),
                    isShared: false,
                    sharedId: null 
                };
                const docRef = await addDoc(notesRef, newNote);
                window.location.hash = `#/notes/${docRef.id}`;
            } catch (error) {
                console.error("Error creating new note:", error);
            }
        };

        const setSaveStatus = (status) => {
            saveStatus = status;
            let text = status;
            let color = isDarkMode ? 'text-gray-400' : 'text-gray-500'; // Default gray for dark/light mode
            
            if (status === 'Typing...') {
                text = 'Typing...';
                color = isDarkMode ? 'text-gray-300' : 'text-gray-500';
            } else if (status === 'Saving...') {
                text = 'Saving...';
                color = 'text-indigo-500';
            } else if (status === 'Saved') {
                text = 'Saved';
                color = 'text-green-600';
            } else if (status === 'Error!') {
                text = 'Error! (Check console)';
                color = 'text-red-500';
            }
            
            saveStatusSpan.textContent = text;
            saveStatusSpan.className = `text-xs font-medium ${color}`;
        };

        const saveActiveNote = async (title, content, tagsString) => {
            if (!activeNoteId || !userId) return;

            const notesRef = getNotesCollectionRef();
            if (!notesRef) return;
            
            const activeNote = notesData.find(note => note.id === activeNoteId);
            const isShared = activeNote?.isShared === true;
            const newTagsArray = parseTags(tagsString);
            
            const initialTitle = activeNote.title || '';
            const initialContent = activeNote.content || '';
            const initialTags = tagsArrayToString(activeNote.tags);
            
            // Check if content actually changed before saving
            if (title === initialTitle && content === initialContent && tagsString === initialTags) {
                 setSaveStatus('Saved');
                 return;
            }

            try {
                setSaveStatus('Saving...');
                const noteDocRef = doc(notesRef, activeNoteId);
                
                const updatePayload = {
                    title: title || '(No Title)',
                    content: content,
                    tags: newTagsArray,
                    updatedAt: serverTimestamp()
                };

                await updateDoc(noteDocRef, updatePayload);

                if (isShared && activeNote.sharedId) {
                    // Update the public, read-only copy
                    const sharedRef = getSharedCollectionRef();
                    const sharedDocRef = doc(sharedRef, activeNote.sharedId);
                    await updateDoc(sharedDocRef, updatePayload);
                }
                
                // Firestore listener will fire and handle setting 'Saved' status and updating time
            } catch (error) {
                console.error("Error saving note:", error);
                setSaveStatus('Error!');
            }
        };
        
        const shareActiveNote = async () => {
            if (!activeNoteId || !userId) return;

            const activeNote = notesData.find(note => note.id === activeNoteId);
            if (!activeNote) return;

            const sharedRef = getSharedCollectionRef();
            const notesRef = getNotesCollectionRef();

            try {
                dynamicShareBtn.disabled = true;
                dynamicShareBtn.title = "Sharing...";

                const baseData = {
                    title: activeNote.title || '(No Title)',
                    content: activeNote.content || '',
                    tags: activeNote.tags || [],
                    authorId: userId, 
                    authorName: auth.currentUser?.email || 'Anonymous User',
                    updatedAt: serverTimestamp(),
                };

                let sharedId = activeNote.sharedId;

                if (activeNote.isShared && activeNote.sharedId) {
                    // Update existing shared doc
                    const sharedDocRef = doc(sharedRef, activeNote.sharedId);
                    await setDoc(sharedDocRef, baseData, { merge: true }); // Use setDoc with merge to ensure doc exists
                } else {
                    // Create new shared doc
                    const sharedDocRef = await addDoc(sharedRef, baseData);
                    sharedId = sharedDocRef.id;

                    // Update local doc with shared info
                    const noteDocRef = doc(notesRef, activeNoteId);
                    await updateDoc(noteDocRef, {
                        isShared: true,
                        sharedId: sharedId,
                    });
                }
                
                const shareUrl = `${window.location.origin}${window.location.pathname}#/shared/${sharedId}`;
                shareUrlInput.value = shareUrl;
                shareModalOverlay.classList.remove('hidden');
                shareModalOverlay.classList.add('flex');
                
                dynamicShareBtn.disabled = false;
                // Listener will trigger setActiveNote and update button icon
            } catch (error) {
                console.error("Error sharing note:", error);
                showConfirmationModal({
                    title: "Sharing Failed",
                    message: `Could not share note due to a permission or network error: ${error.message}`,
                    confirmText: "Close",
                    confirmClass: "bg-indigo-600 hover:bg-indigo-700",
                    onConfirm: hideModal,
                    showCancel: false
                });
                dynamicShareBtn.disabled = false;
            }
        };
        
        const unshareActiveNote = async () => {
             if (!activeNoteId || !userId) return;

            const activeNote = notesData.find(note => note.id === activeNoteId);
            if (!activeNote || !activeNote.isShared || !activeNote.sharedId) return;
            
            const sharedRef = getSharedCollectionRef();
            const notesRef = getNotesCollectionRef();
            const sharedId = activeNote.sharedId;

            try {
                // Delete the public copy
                const sharedDocRef = doc(sharedRef, sharedId);
                await deleteDoc(sharedDocRef);
                
                // Update the user's private copy
                const noteDocRef = doc(notesRef, activeNoteId);
                await updateDoc(noteDocRef, {
                    isShared: false,
                    sharedId: null,
                    updatedAt: serverTimestamp()
                });
                
                // Listener will trigger setActiveNote and update button icon
            } catch (error) {
                console.error("Error unsharing note:", error);
                 showConfirmationModal({
                    title: "Unsharing Failed",
                    message: `Could not remove the public copy: ${error.message}`,
                    confirmText: "Close",
                    confirmClass: "bg-indigo-600 hover:bg-indigo-700",
                    onConfirm: hideModal,
                    showCancel: false
                });
            }
        };


        // --- UI RENDERING & DISPLAY ---
        
        const renderMarkdown = (markdownText) => {
            // marked is synchronous by default
            return marked.parse(markdownText || '');
        }

        // FIX: Added missing updateMarkdownView function
        const updateMarkdownView = (content) => {
            if (isMarkdownPreview) {
                 markdownPreviewDiv.innerHTML = renderMarkdown(content);
            }
        };

        const getRelativeTime = (date) => {
            if (!date || date.getTime() === 0) return 'Never';
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " years ago";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " months ago";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " days ago";
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " hours ago";
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " minutes ago";
            if (seconds < 5) return "just now";
            return Math.floor(seconds) + " seconds ago";
        };


        const renderNoteList = () => {
            const term = searchTerm.toLowerCase().trim();
            const isTagSearch = term.startsWith('#');
            const tagTerm = isTagSearch ? term.substring(1) : '';

            // Update search input appearance based on search type
            if (isTagSearch && tagTerm) {
                searchIcon.dataset.lucide = 'hash';
                searchIcon.classList.remove('text-gray-400', 'text-indigo-500');
                searchIcon.classList.add('text-indigo-500');
            } else {
                searchIcon.dataset.lucide = 'search';
                searchIcon.classList.remove('text-indigo-500');
                searchIcon.classList.add('text-gray-400');
            }
            lucide.createIcons();


            const filteredNotes = notesData.filter(note => {
                if (!term) return true;
                
                if (isTagSearch && tagTerm) {
                    return note.tags?.some(tag => tag.includes(tagTerm)) || false;
                } else {
                    // Filter by title, content, OR tags
                    const titleMatch = note.title?.toLowerCase().includes(term);
                    const contentMatch = note.content?.toLowerCase().includes(term);
                    const tagMatch = note.tags?.some(tag => tag.includes(term)); 
                    return titleMatch || contentMatch || tagMatch;
                }
            });
            
            // Sort by updatedAt, newest first
            filteredNotes.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());

            notesListElement.innerHTML = '';
            
            if (filteredNotes.length === 0) {
                notesListElement.innerHTML = `<p class="p-4 text-center text-gray-400">${term ? `No notes found matching "${term}".` : `Create your first note by clicking the '+' button!`}</p>`;
                return;
            }

            filteredNotes.forEach(note => {
                const isActive = note.id === activeNoteId;
                const noteItem = document.createElement('a');
                noteItem.href = `#/notes/${note.id}`;
                
                // Use isDarkMode to correctly set hover/background for list items
                const itemClasses = isActive 
                    ? 'active bg-indigo-100 ring-2 ring-indigo-500 shadow-md' 
                    : isDarkMode 
                        ? 'bg-[#161b22] hover:bg-[#30363d]' 
                        : 'bg-gray-50 hover:bg-gray-100';

                noteItem.className = `p-4 mb-2 rounded-xl cursor-pointer block transition duration-150 ${itemClasses}`;
                
                // Refactored tag rendering 
                const tagsHtml = note.tags && note.tags.length > 0
                    ? `<div class="mt-1 flex flex-wrap gap-1">${note.tags.map(tag => `<span class="tag-pill">#${tag}</span>`).join('')}</div>`
                    : '';
                
                const contentSnippet = stripMarkdown(note.content);
                
                noteItem.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <h3 class="font-semibold ${isActive ? 'text-indigo-800' : 'text-gray-800'} truncate">${note.title || '(No Title)'}</h3>
                        ${note.isShared ? '<i data-lucide="link" class="w-4 h-4 text-green-500 flex-shrink-0" title="Shared"></i>' : ''}
                    </div>
                    <p class="text-xs text-gray-500 mb-1">${getRelativeTime(note.updatedAt)}</p>
                    ${tagsHtml}
                    <p class="text-sm text-gray-600 line-clamp-2 mt-2">${contentSnippet || 'Empty note...'}</p>
                `;
                notesListElement.appendChild(noteItem);
            });
            lucide.createIcons();
        };
        

        const toggleMarkdownPreview = (force = null) => {
            isMarkdownPreview = force !== null ? force : !isMarkdownPreview;
            
            if (isMarkdownPreview) {
                noteContentTextarea.classList.add('hidden');
                markdownPreviewDiv.classList.remove('hidden');
                markdownToggleBtn.innerHTML = '<i data-lucide="file-pen" class="w-5 h-5"></i>';
                markdownToggleBtn.title = "Toggle Editing Mode";
                // FIX: Explicitly update the view when entering preview mode
                updateMarkdownView(noteContentTextarea.value); 
            } else {
                noteContentTextarea.classList.remove('hidden');
                markdownPreviewDiv.classList.add('hidden');
                markdownToggleBtn.innerHTML = '<i data-lucide="eye" class="w-5 h-5"></i>';
                markdownToggleBtn.title = "Toggle Markdown Preview";
                noteContentTextarea.focus();
            }
            lucide.createIcons();
        };

        const toggleSidebar = (force = null) => {
            isSidebarOpen = force !== null ? force : !isSidebarOpen;
            if (isSidebarOpen) {
                // Show: full width on mobile (if needed, but handled by routing) or w-80 on desktop
                notesListContainer.classList.remove('md:w-0', 'w-0', 'hidden');
                notesListContainer.classList.add('md:w-80', 'w-full');
                toggleSidebarBtn.innerHTML = '<i data-lucide="panel-left-close" class="w-5 h-5"></i>';
            } else {
                // Hide: w-0 on desktop
                notesListContainer.classList.add('md:w-0', 'w-0');
                notesListContainer.classList.remove('md:w-80', 'w-full');
                toggleSidebarBtn.innerHTML = '<i data-lucide="panel-left-open" class="w-5 h-5"></i>';
            }
            lucide.createIcons();
        };


        const setActiveNote = (noteId, focus = true) => {
            activeNoteId = noteId;
            const activeNote = notesData.find(note => note.id === noteId);

            if (activeNote) {
                // UI Setup
                document.title = (activeNote.title || 'Untitled') + ' | Notes';
                noteEditorContainer.classList.remove('hidden', 'md:hidden');
                noteEditorContainer.classList.add('flex');
                emptyEditorState.classList.add('hidden');
                backToListBtn.classList.toggle('hidden', !isMobileView());

                // Data Population
                noteTitleInput.value = activeNote.title || '';
                noteTagsInput.value = tagsArrayToString(activeNote.tags);
                noteContentTextarea.value = activeNote.content || '';
                
                // Bug Fix: Use activeNote's timestamp to update the UI immediately
                lastEditedTimeSpan.textContent = 'Last edited: ' + getRelativeTime(activeNote.updatedAt); 

                deleteNoteBtn.classList.remove('opacity-50', 'pointer-events-none');
                
                // Dynamic Share/Unshare Button Logic
                dynamicShareBtn.classList.remove('opacity-50', 'pointer-events-none', 'text-green-600', 'hover:bg-green-50', 'text-red-600', 'hover:bg-red-50');
                
                if (activeNote.isShared) {
                    // Unshare action (red color, rotated icon)
                    dynamicShareBtn.innerHTML = '<i data-lucide="link-2-off" class="w-5 h-5"></i>'; 
                    dynamicShareBtn.title = "Unshare Note (Delete Public Link)";
                    dynamicShareBtn.classList.add('text-red-600', 'hover:bg-red-50'); 
                    dynamicShareBtn.onclick = () => showConfirmationModal({
                        title: "Confirm Unshare",
                        message: "Are you sure you want to unshare this note? The public link will stop working immediately.",
                        confirmText: "Unshare",
                        confirmClass: "bg-red-600 hover:bg-red-700",
                        onConfirm: unshareActiveNote
                    });
                } else {
                    // Share action (green color, standard icon)
                    dynamicShareBtn.innerHTML = '<i data-lucide="share-2" class="w-5 h-5"></i>';
                    dynamicShareBtn.title = "Share Note (Create Public Link)";
                    dynamicShareBtn.classList.add('text-green-600', 'hover:bg-green-50');
                    dynamicShareBtn.onclick = shareActiveNote;
                }

                setSaveStatus('Saved');
                toggleMarkdownPreview(false);
                if (focus) {
                    noteTitleInput.focus();
                }

            } else {
                // Clear and hide editor (Note: Mobile routing handles the hidden/shown state of list/editor)
                noteTitleInput.value = '';
                noteTagsInput.value = '';
                noteContentTextarea.value = '';
                lastEditedTimeSpan.textContent = 'Last edited: --';
                deleteNoteBtn.classList.add('opacity-50', 'pointer-events-none');
                dynamicShareBtn.classList.add('opacity-50', 'pointer-events-none');
                setSaveStatus('');
                
                // Show Empty State on Desktop/Tablet
                if (!isMobileView()) {
                    noteEditorContainer.classList.add('hidden');
                    emptyEditorState.classList.remove('hidden');
                }
                document.title = "Secure Cloud Notes";
            }

            renderNoteList();
            lucide.createIcons();
        };
        
        const renderSharedNote = async (sharedId) => {
            const sharedRef = getSharedCollectionRef();
            const sharedDocRef = doc(sharedRef, sharedId);
            
            sharedTitle.textContent = 'Loading Note...';
            sharedMeta.innerHTML = '';
            sharedMarkdownContent.innerHTML = '';
            sharedEditBtn.classList.add('hidden');
            
            try {
                const docSnap = await getDoc(sharedDocRef);
                
                if (docSnap.exists()) {
                    const note = docSnap.data();
                    
                    document.title = (note.title || 'Untitled Shared Note');
                    sharedTitle.textContent = note.title || 'Untitled Note';
                    
                    const timeString = note.updatedAt ? new Date(note.updatedAt.toDate()).toLocaleString() : 'N/A';
                    
                    // Tag rendering (Bug Fix: ensure tags are styled correctly in the viewer)
                    const tagsHtml = note.tags && note.tags.length > 0
                        ? `<div class="mt-2 flex flex-wrap gap-2">${note.tags.map(tag => `<span class="tag-pill text-xs px-2 py-1">#${tag}</span>`).join('')}</div>`
                        : '';
                        
                    sharedMeta.innerHTML = `
                        <p>Shared by <strong>${note.authorName || 'a user'}</strong> | Last updated: ${timeString}</p>
                        ${tagsHtml}
                    `;
                    
                    sharedMarkdownContent.innerHTML = renderMarkdown(note.content || '');
                    
                    // Feature: Allow the author to go straight to edit view
                    if (note.authorId === userId) {
                        sharedEditBtn.classList.remove('hidden');
                        // Find the note's ID from the current user's notes collection 
                        const userNotesRef = getNotesCollectionRef();
                        const q = query(userNotesRef);
                        
                        // FIX: getDocs is now correctly imported
                        const userNotesSnapshot = await getDocs(q); 
                        
                        const originalNoteDoc = userNotesSnapshot.docs.find(d => d.data().sharedId === sharedId);

                        if (originalNoteDoc) {
                             sharedEditBtn.onclick = () => {
                                window.location.hash = `#/notes/${originalNoteDoc.id}`;
                             };
                        } else {
                            // Should not happen if data is consistent, but handles edge case
                            sharedEditBtn.classList.add('hidden');
                        }
                    } else {
                        sharedEditBtn.classList.add('hidden');
                    }

                } else {
                    sharedTitle.textContent = 'Note Not Found (404)';
                    sharedMeta.innerHTML = 'The shared note link is invalid or the note has been deleted by the owner.';
                    sharedMarkdownContent.innerHTML = '';
                }
            } catch (error) {
                console.error("Error loading shared note:", error);
                sharedTitle.textContent = 'An Error Occurred';
                sharedMeta.innerHTML = 'Could not load note due to a connection error.';
                sharedMarkdownContent.innerHTML = `<p class="text-red-500">${error.message}</p>`;
            } finally {
                hideLoadingSpinner();
                lucide.createIcons();
            }
        };


        // --- REUSABLE MODAL/DIALOG LOGIC ---
        let currentModalAction = null;

        const showConfirmationModal = ({ title, message, confirmText, confirmClass, onConfirm, showCancel = true }) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalConfirmBtn.textContent = confirmText;
            
            modalConfirmBtn.className = "px-4 py-2 text-white rounded-lg transition duration-150 " + (confirmClass || "bg-red-600 hover:bg-red-700");
            
            modalCancelBtn.classList.toggle('hidden', !showCancel);

            currentModalAction = onConfirm;

            modalOverlay.classList.remove('hidden');
            modalOverlay.classList.add('flex');
        };

        const hideModal = () => {
            modalOverlay.classList.add('hidden');
            modalOverlay.classList.remove('flex');
            currentModalAction = null;
        };
        
        // --- EVENT HANDLERS ---

        const setupEventListeners = () => {
            window.addEventListener('hashchange', handleRouting);
            window.addEventListener('resize', handleRouting); // Use routing for responsiveness
            
            // Dark Mode Toggle
            darkModeToggleBtn.addEventListener('click', toggleDarkMode);
            
            // Auth Events
            authPrimaryBtn.addEventListener('click', handlePrimaryAuthAction);
            authGoogleBtn.addEventListener('click', handleGoogleSignIn);
            
            // Auth hash links (FIXED to prevent page reload)
            authToggleLink.addEventListener('click', (e) => {
                e.preventDefault();
                const newHash = e.target.getAttribute('href');
                window.location.hash = newHash;
            });
            authResetLink.addEventListener('click', (e) => {
                e.preventDefault();
                window.location.hash = e.target.getAttribute('href');
            });


            // Modal Events
            modalCancelBtn.addEventListener('click', hideModal);
            modalConfirmBtn.addEventListener('click', async () => {
                if (currentModalAction) {
                    await currentModalAction();
                }
                hideModal();
            });

            // App Events
            signoutBtn.addEventListener('click', handleSignOut);
            newNoteBtn.addEventListener('click', createNewNote);
            
            // Search Input 
            searchInput.addEventListener('input', (e) => {
                searchTerm = e.target.value;
                renderNoteList();
            });


            // Delete handler
            deleteNoteBtn.addEventListener('click', () => showConfirmationModal({
                title: "Confirm Deletion",
                message: "Are you sure you want to delete this note? This action cannot be undone and will also delete the public sharing link if one exists.",
                confirmText: "Delete Permanently",
                confirmClass: "bg-red-600 hover:bg-red-700",
                onConfirm: async () => {
                     if (!activeNoteId || !userId) return;
                    const notesRef = getNotesCollectionRef();
                    const activeNote = notesData.find(note => note.id === activeNoteId);
                    if (!notesRef || !activeNote) return;

                    try {
                        if (activeNote.isShared && activeNote.sharedId) {
                            const sharedRef = getSharedCollectionRef();
                            await deleteDoc(doc(sharedRef, activeNote.sharedId));
                        }
                        await deleteDoc(doc(notesRef, activeNoteId));
                        window.location.hash = '#/';
                    } catch (error) {
                        console.error("Error deleting note:", error);
                        setSaveStatus('Error!');
                    }
                }
            }));

            // Auto-save logic with debounce
            const handleInputChange = () => {
                if (!activeNoteId || !userId) return;

                const title = noteTitleInput.value;
                const tagsString = noteTagsInput.value;
                const content = noteContentTextarea.value;
                
                setSaveStatus('Typing...');
                
                if (saveTimer) {
                    clearTimeout(saveTimer);
                }

                saveTimer = setTimeout(() => {
                    saveActiveNote(title, content, tagsString);
                }, 1000);
                
                if (isMarkdownPreview) {
                    // Update markdown view in real-time if preview is active
                    updateMarkdownView(content);
                }
            };

            noteTitleInput.addEventListener('input', handleInputChange);
            noteTagsInput.addEventListener('input', handleInputChange);
            noteContentTextarea.addEventListener('input', handleInputChange);

            // Feature Button Handlers
            toggleSidebarBtn.addEventListener('click', toggleSidebar);
            markdownToggleBtn.addEventListener('click', () => toggleMarkdownPreview());

            // Share Modal Handlers
            shareModalCloseBtn.addEventListener('click', () => {
                shareModalOverlay.classList.add('hidden');
                shareModalOverlay.classList.remove('flex');
            });
            // Using execCommand for wider compatibility (GitHub Pages context)
            copyShareUrlBtn.addEventListener('click', () => {
                shareUrlInput.select();
                shareUrlInput.setSelectionRange(0, 99999); 
                document.execCommand('copy');
                copyShareUrlBtn.innerHTML = '<i data-lucide="check" class="w-4 h-4 mr-2"></i> Copied!';
                lucide.createIcons();
                setTimeout(() => {
                    copyShareUrlBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4 mr-2"></i> Copy';
                    lucide.createIcons();
                }, 2000);
            });


            // Mobile back button routes to list 
            backToListBtn.addEventListener('click', () => {
                window.location.hash = '#/';
            });
        };


        // --- APPLICATION START ---

        document.addEventListener('DOMContentLoaded', () => {
            initializeDarkMode(); 
            
            // Set initial hash if none exists to trigger routing logic
            if (!window.location.hash) {
                window.location.hash = '#/';
            }
            
            lucide.createIcons();
            setupEventListeners();
            initializeFirebase();
        });

    </script>
</body>
</html>
